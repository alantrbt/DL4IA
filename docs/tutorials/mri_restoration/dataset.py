import os
import torch
from torch.utils.data import Dataset

import numpy as np


class mriData(Dataset):
    """Dataset of MRI data in k-space.
    """
    def __init__(self, data_folder):
        super(mriData, self).__init__()
        self.data_folder = data_folder
        self.files = os.listdir(data_folder)
        self.files.sort()

    def __len__(self):
        return len(self.files)
    
    def __getitem__(self, i):
        file = self.files[i]
        file_name = os.path.join(self.data_folder, file)
        kspace = np.load(file_name)
        kspace = torch.from_numpy(kspace)
        return kspace


class fastMriData(mriData):
    """Dataset that simulates the acceleration of the 
    MRI data acquisition process, given an unsersampling scheme.
    Gives pairs for training a ML model to reconstruct MRI from
    undersampled measurements.
    """
    def __init__(self, data_folder: str, mask: torch.Tensor, mean: float, std: float):
        super(fastMriData, self).__init__(data_folder)
        self.mask = mask
        
        if mean is None or std is None:
            self.mean, self.std = self.dataset_statistics()
        else:
            self.mean = mean
            self.std = std

    def dataset_statistics(self):
        """Computes mean and std over every images in dataset.
        """
        images = []
        for i in range(len(self)):
            target_kspace = super().__getitem__(i)
            _, obs_image = self.measurement(target_kspace, self.mask)
            images.append(obs_image)
        
        images = torch.cat(images)
        mean = torch.mean(images)
        std = torch.std(images)
        return mean, std
    
    @staticmethod
    def measurement(target_kspace: torch.Tensor, mask: torch.Tensor):
        """Simulates a measurement.
        """
        obs_kspace = torch.zeros_like(target_kspace)
        obs_kspace[:, mask] = target_kspace[:, mask]
        obs_image = torch.abs(
            torch.fft.ifftn(obs_kspace)
            )
        return obs_kspace, obs_image

    def __getitem__(self, i):
        target_kspace = super().__getitem__(i)
        target_image = torch.abs(torch.fft.ifftn(target_kspace))

        obs_kspace, obs_image = self.measurement(target_kspace, self.mask)

        obs_image = (obs_image.float() - self.mean) / self.std
        target_image = (target_image.float() - self.mean) / self.std

        obs_kspace = torch.fft.fftshift(torch.fft.fftn(obs_image))
        target_kspace = torch.fft.fftshift(torch.fft.fftn(target_image))

        return obs_image, obs_kspace, target_image, target_kspace


def kspace_mask(kspace_shape, acceleration_factor: int = 4):
    """Implementation of Cartesian Undersampling, as described in:
    Knoll et al. (2020). fastMRI: A Publicly Available Raw k-Space and DICOM Dataset 
    of Knee Images for Accelerated MR Image Reconstruction Using Machine Learning. 
    Radiology: Artificial Intelligence. doi: 10.1148/ryai.2020190007.

    "All undersampling masks are generated by first including some number of adjacent lowest-
    frequency k-space lines to provide a fully-sampled k-space region. When the acceleration factor
    equals four, the fully-sampled central region includes 8% of all k-space lines; when it equals eight,
    4% of all k-space lines are included." Remaining k-space lines are, here, included uniformly at random.
    """
    n_columns = kspace_shape[-1]
    center = n_columns // 2
    n_tot = n_columns // acceleration_factor
    
    if acceleration_factor == 4:
        n_center = int(n_columns * 0.08)
    elif acceleration_factor == 8:
        n_center = int(n_columns * 0.04)
    else:
        raise ValueError("Only acceleration factors 4 and 8 are supported.")

    random_mask = np.zeros(n_columns)
    random_mask[center - n_center // 2 : center + n_center // 2] = 1

    n_high_freq = n_tot - n_center
    high_freq = np.concatenate((
        np.arange(center - n_center // 2),
        np.arange(center + n_center // 2 - 1, n_columns)
        ))
    
    high_freq = np.random.choice(high_freq, size=n_high_freq, replace=False)
    random_mask[high_freq] = 1
    random_mask = torch.from_numpy(random_mask == 1)

    return random_mask