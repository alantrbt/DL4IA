import torch

import numpy as np
from numpy.typing import NDArray
from typing import Union, Tuple, Callable

import cv2
import jpeg4py as jpeg


from tqdm import tqdm
import matplotlib.pyplot as plt
import matplotlib.colors as colors


def read_image(image_path: str) -> NDArray[np.uint8]:
    """Credit: github.com/xevolesi/alexnet_pytorch/blob/master/source/datasets/utils.py
    """
    try:
        image = jpeg.JPEG(image_path).decode()
    except jpeg.JPEGRuntimeError:
        image = cv2.imread(image_path)
        image = cv2.cvtColor(image, cv2.COLOR_BGR2RGB)
    return image


def show_samples_per_class(
        data: torch.Tensor, 
        labels: torch.Tensor, 
        class_id: int, 
        n_samples: int = 10, 
        figsize=(10,10)) -> None:
    """Show random data points from a given class.
    """
    fig, ax = plt.subplots(1, n_samples, figsize=figsize)
    samples = data[labels == class_id]
    samples = samples.numpy()
    np.random.shuffle(samples)
    samples = samples[:n_samples]
    for i in range(n_samples):
        img = samples[i]
        if img.shape[0] == 3:  # (C, H, W)
            img = np.transpose(img, (1, 2, 0))  # (H, W, C)
        ax[i].imshow(img)
        ax[i].set_xticks([])
        ax[i].set_yticks([])
    plt.show()


def data_stats(dataset: torch.utils.data.Dataset, batch_size: int = 1024) -> Tuple[float, float]:
    """Compute mean and standard deviation across spatial dimensions and samples
    in a dataset of RGB images. Draft generated by Le Chat, an AI assistant developed by Mistral AI.
    """
    data_loader = torch.utils.data.DataLoader(
        dataset,
        batch_size=batch_size
    )
    sum_values = 0
    sum_squared_values = 0
    num_elements = 0
    for batch in tqdm(data_loader, desc='Compute mean and std over dataset'):
        if batch.shape[-1] == 3:
            batch = batch.view(-1, 3)
        else:
            raise NotImplementedError("Batch last dimension != 3")
        sum_values += torch.sum(batch, dim=0)
        sum_squared_values += torch.sum(batch**2, dim=0)
        num_elements += batch.size(0)
    
    mean = sum_values / num_elements
    std = torch.sqrt(sum_squared_values / num_elements)
    return mean, std


def dataset2tensor(
        dataset: torch.utils.data.Dataset,
        batch_size: int = 64) -> Tuple[torch.Tensor, torch.Tensor]:
    """Store all dataset (data x labels) into tensors.
    """
    data, labels = [], []
    loader = torch.utils.data.DataLoader(
        dataset, 
        batch_size=batch_size)
    for sample, label in loader:
        data.append(sample)
        labels.append(label)
    data = torch.cat(data)
    labels = torch.cat(labels)
    return data, labels


def deprocess_image(x: Union[torch.Tensor, np.ndarray], mean=None, std=None) -> np.ndarray:
    """Un-normalize image for visualisation.
    """
    if len(x.shape) == 4:
        x = x[0, :, :, :]
    if isinstance(x, torch.Tensor):
        x = x.numpy()

    # normalize tensor: center on 0., ensure std is 0.1
    if mean is None:
        mean = np.mean(x, axis=(1, 2))
    else:
        mean = np.array(mean)
    if std is None:
        std = np.std(x, axis=(1, 2))
    else:
        std = np.array(std)
        
    x -= mean.reshape(-1, 1, 1)
    x /= (std.reshape(-1, 1, 1) + 1e-5)
    x *= 0.1

    # clip to [0, 1]
    x += 0.5
    x = np.clip(x, 0, 1)

    # convert to RGB array
    x *= 255
    x = x.transpose((1, 2, 0))
    x = np.clip(x, 0, 255).astype('uint8')
    return x


class MidpointNormalize(colors.Normalize):
	"""Credit: https://chris35wills.github.io/matplotlib_diverging_colorbar/
	Normalise the colorbar so that diverging bars work there way either side from a prescribed midpoint value)

	e.g. im=ax1.imshow(array, norm=MidpointNormalize(midpoint=0.,vmin=-100, vmax=100))
	"""
	def __init__(self, vmin=None, vmax=None, midpoint=None, clip=False):
		self.midpoint = midpoint
		colors.Normalize.__init__(self, vmin, vmax, clip)

	def __call__(self, value, clip=None):
		# I'm ignoring masked values and all kinds of edge cases to make a
		# simple example...
		x, y = [self.vmin, self.midpoint, self.vmax], [0, 0.5, 1]
		return np.ma.masked_array(np.interp(value, x, y), np.isnan(value))